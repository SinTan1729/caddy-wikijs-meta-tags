// SPDX-FileCopyrightText: 2025 Sayantan Santra <sayantan.santra689@gmail.com>
// SPDX-License-Identifier: Apache-2.0

package metatags

import (
	"fmt"
	"strings"

	"github.com/caddyserver/caddy/v2"
	"github.com/caddyserver/caddy/v2/caddyconfig/caddyfile"
	"github.com/caddyserver/caddy/v2/caddyconfig/httpcaddyfile"
	"github.com/caddyserver/caddy/v2/modules/caddyhttp"
	"github.com/wasilibs/go-re2"
	"go.uber.org/zap"
)

func init() {
	caddy.RegisterModule(Handler{})
	httpcaddyfile.RegisterHandlerDirective("wikijs_metatags", parseCaddyfile)
	httpcaddyfile.RegisterDirectiveOrder("wikijs_metatags", httpcaddyfile.After, "encode")
}

// Handler is an example; put your own type here.
type Handler struct {
	// Default values when nothing can be figured out from the page
	// The DefaultImageURL entry must be a valid publicly accessible path
	// The hostname will be automatically added, so it should start with a slash (/)
	// If InsertTopic is true (it is false by default), an attempt will
	// be made to insert a topic after the description. It probably isn't worth it.
	DefaultDescription string `json:"default_description,omitempty"`
	DefaultImagePath   string `json:"default_image_path,omitempty"`
	InsertTopic        bool   `json:"insert_topic"`
	TopicRegex         string `json:"topic_regex,omitempty"`

	// The variable below are autogenerated
	topicRegexCompiled *re2.Regexp
	imageRegexCompiled *re2.Regexp
	// Get a logger from the context
	logger *zap.Logger
}

// Handler performs the necessary insertions
func (Handler) CaddyModule() caddy.ModuleInfo {
	return caddy.ModuleInfo{
		ID: "http.handlers.wikijs_metatags",
		New: func() caddy.Module {
			return new(Handler)
		},
	}
}

// Provision implements caddy.Provisioner
func (h *Handler) Provision(ctx caddy.Context) error {
	h.logger = ctx.Logger()
	// Make sure that the provided default image, if any,
	// is valid for og:image meta tags
	if h.DefaultImagePath != "" {
		url := h.DefaultImagePath
		startsSlash := strings.HasPrefix(url, "/")
		startsHTTPS := strings.HasPrefix(url, "https://")
		endsJPG := strings.HasSuffix(url, ".jpg")
		endsPNG := strings.HasSuffix(url, ".png")
		endsGIF := strings.HasSuffix(url, ".gif")
		endsWEBP := strings.HasSuffix(url, ".webp")

		if !(startsSlash || startsHTTPS) || !(endsJPG || endsPNG || endsGIF || endsWEBP) {
			return fmt.Errorf("Default Image Path is invalid. Only jpg, png, gif, and webp links work.")
		}
	}
	// If insert_topic is enabled, make sure that a valid regex is provided
	if h.InsertTopic {
		if h.TopicRegex == "" {
			return fmt.Errorf("Empty topic_regex was provided, but insert_topic was enabled.")
		}
		var err error
		h.topicRegexCompiled, err = re2.Compile(h.TopicRegex)
		if err != nil {
			return fmt.Errorf("Error compiling provided topic_regex.")
		}
	}
	// Compile and store the image regex
	img_pattern := `<img .*src="(.+\.(?:jpg|png|webp|gif))".*>`
	h.imageRegexCompiled = re2.MustCompile(img_pattern)

	return nil
}

// Interface guards
var (
	_ caddy.Provisioner           = (*Handler)(nil)
	_ caddyhttp.MiddlewareHandler = (*Handler)(nil)
	_ caddyfile.Unmarshaler       = (*Handler)(nil)
)
